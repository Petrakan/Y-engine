### Domain layer.

Этот слой содержит основные концепции и бизнес-правила системы. Он определяет сущности, объекты значений и отношения, которые составляют доменную модель системы. Доменный уровень должен быть разработан таким образом, чтобы не зависеть от какой-либо конкретной инфраструктуры или пользовательского интерфейса, чтобы его можно было повторно использовать на различных платформах или в различных приложениях. Он также должен быть спроектирован таким образом, чтобы его можно было тестировать в отрыве от других уровней.

1. **Entities:**
  
    Сущность - это уникальный объект или концепция в доменной модели. Она может представлять клиента, продукт, заказ или любую другую сущность, имеющую отношение к бизнес-сфере. Сущности обычно имеют идентификатор, который отличает их от других сущностей, и могут иметь атрибуты, которые описывают их свойства или характеристики. Доменный уровень определяет сущности и их атрибуты, а также предоставляет методы для взаимодействия с ними.

    Вот некоторые функции, которые сущности должны выполнять на уровне домена:

    * _Encapsulate state:_

        Сущности должны инкапсулировать состояние определенной доменной концепции и предоставлять последовательный и предсказуемый интерфейс для взаимодействия с прикладным уровнем. Состояние сущности должно быть четко определено и не должно быть доступно или изменено непосредственно прикладным уровнем.

    * _Implement behavior:_

        Сущности должны реализовывать поведение или бизнес-логику определенной концепции домена. Это поведение должно быть хорошо определено и должно быть инкапсулировано внутри сущности, чтобы его можно было легко тестировать и изменять по мере необходимости.

    * _Enforce business rules:_

        Сущности должны обеспечивать выполнение бизнес-правил или ограничений, которые определяют поведение приложения. Например, если приложение требует, чтобы пользователь имел уникальный адрес электронной почты, сущность должна обеспечить выполнение этого ограничения и не допустить, чтобы несколько пользователей имели один и тот же адрес электронной почты.

    * _Provide identity:_

        Сущности должны иметь уникальную идентификацию, которая отличает их от других сущностей в системе. Эта идентификация может использоваться для отслеживания состояния сущности во времени и для обеспечения соблюдения определенных ограничений или бизнес-правил.

    * _Enable persistence:_

        Сущности должны обеспечивать персистентность, предоставляя механизм для хранения и извлечения их состояния из постоянного хранилища, такого как база данных. Этого можно достичь с помощью библиотек Rust, таких как Diesel или SQLx.

2. **Value objects:**
  
    Объект значения - это объект, который представляет значение или концепцию в доменной модели. В отличие от сущностей, объекты значений не имеют идентичности и определяются исключительно своими атрибутами. Примерами объектов значений являются даты, время, валюты и измерения. Доменный уровень определяет объекты значений и их атрибуты, а также предоставляет методы для взаимодействия с ними.
    
    Вот некоторые функции, которые объекты значения должны выполнять на уровне домена:

    * _Encapsulate state:_

        Объекты значений должны инкапсулировать состояние определенной доменной концепции и предоставлять последовательный и предсказуемый интерфейс для взаимодействия с прикладным уровнем. Состояние объекта значения должно быть четко определено и не должно быть доступно или изменено непосредственно прикладным уровнем.

    * _Provide immutability:_

        Объекты значений должны быть неизменяемыми, то есть после их создания их состояние не может быть изменено. Это гарантирует, что состояние объекта значения является последовательным и предсказуемым, и что его можно легко использовать совместно и повторно в рамках приложения.

    * _Implement behavior:_

        Объекты значений должны реализовывать поведение или операции, характерные для концепции домена, которую они представляют. Например, объект значения, представляющий дату, может реализовать операции для вычисления разницы между двумя датами или для форматирования даты определенным образом.

    * _Enforce constraints:_

        Объекты значений должны обеспечивать выполнение ограничений или правил, специфичных для концепции домена, которую они представляют. Например, объект значения, представляющий денежную сумму, может применять такие ограничения, как максимальное или минимальное значение, или определенный код валюты.

    * _Enable reuse:_

        Объекты значений должны быть спроектированы так, чтобы их можно было легко использовать совместно и повторно в рамках всего приложения. Инкапсулируя состояние и поведение определенной концепции домена, объекты значений могут использоваться для обеспечения последовательного и предсказуемого интерфейса во всем приложении, а также для обеспечения ограничений и правил, специфичных для концепции домена.

3. **Aggregates:**

    Агрегат - это кластер связанных объектов в доменной модели, которые рассматриваются как единое целое. Агрегат обеспечивает согласованность и целостность в пределах своих границ, гарантируя, что все изменения в составляющих его объектах производятся согласованным и атомарным образом. Доменный уровень определяет агрегаты и их границы, а также предоставляет методы для взаимодействия с ними.

    Вот некоторые функции, которые агрегаты должны выполнять на уровне домена:

    * _Encapsulate related entities and value objects:_

        Агрегаты должны инкапсулировать связанные сущности и объекты значений, которые являются частью определенной концепции домена или бизнес-транзакции. Это обеспечивает согласованность состояния доменной модели и атомарное выполнение транзакций.

    * _Provide transactional consistency:_

        Агрегаты должны обеспечивать транзакционную согласованность, гарантируя, что состояние агрегата всегда достоверно и согласовано, даже при наличии ошибок или исключений.

    * _Enforce business rules:_

        Агрегаты должны обеспечивать выполнение бизнес-правил или ограничений, которые применяются к концепции домена, которую они представляют. Например, агрегат, представляющий заказ, может обеспечить выполнение таких ограничений, как минимальное количество заказа, максимальная стоимость заказа или переход статуса заказа.

    * _Manage concurrency:_

        Агрегаты должны управлять параллелизмом, определяя четкие границы для одновременного доступа и обновления связанных сущностей и объектов значений. Это гарантирует, что несколько транзакций могут выполняться параллельно без ущерба для согласованности модели домена.

    * _Provide a consistent interface:_

        Агрегаты должны предоставлять согласованный интерфейс для взаимодействия с прикладным уровнем. Этот интерфейс должен абстрагироваться от сложности доменной модели и обеспечивать простой и интуитивно понятный способ выполнения бизнес-транзакций для прикладного уровня.

4. **Repositories:**

    Репозиторий - это интерфейс, определяющий, как объекты доменной модели могут быть получены, добавлены, обновлены и удалены из постоянной системы хранения, например, из базы данных. Доменный уровень предоставляет интерфейсы репозиториев, которые могут быть реализованы инфраструктурным уровнем для выполнения этих операций.

    Вот некоторые функции, которые хранилища должны выполнять на уровне домена:

    * _Provide a consistent interface:_

        Репозитории должны предоставлять последовательный и четко определенный интерфейс для взаимодействия с прикладным уровнем. Этот интерфейс должен абстрагировать детали того, как хранятся и извлекаются данные, и должен обеспечивать простой и интуитивно понятный способ для прикладного уровня выполнять операции CRUD над объектами домена.

    * _Manage persistence:_

        Хранилища должны управлять сохранением доменных объектов, предоставляя операции создания, чтения, обновления и удаления доменных объектов из базового хранилища данных. Хранилище должно инкапсулировать конкретные детали того, как хранятся и извлекаются данные, например, SQL-запросы или запросы к базе данных, необходимые для извлечения доменных объектов.

    * _Manage transactions:_

        Хранилища должны управлять транзакциями, предоставляя операции для запуска, фиксации и отката транзакций. Это гарантирует, что объекты домена сохраняются атомарно и последовательно, даже при возникновении ошибок или исключений.

    * _Enforce domain constraints:_

        Хранилища должны обеспечивать соблюдение ограничений домена путем проверки доменных объектов перед их сохранением в базовом хранилище данных. Это гарантирует, что будут сохранены только корректные объекты домена и целостность доменной модели.

    * _Provide extensibility:_

        Хранилища должны быть спроектированы таким образом, чтобы их можно было легко расширять и настраивать в соответствии с конкретными требованиями приложения. Например, хранилище может предоставлять возможность поиска доменных объектов по определенным критериям или получения связанных доменных объектов.

5. **Domain services:**

    Служба домена - это объект без статического состояния, который выполняет определенную задачу или операцию в рамках модели домена. Доменные сервисы обычно используются для координации действий между различными сущностями или агрегатами или для выполнения сложной бизнес-логики, которая не может быть выражена в рамках одной сущности или агрегата. Доменный уровень определяет доменные сервисы и их операции.

    Вот некоторые функции, которые доменные сервисы должны выполнять на уровне домена:

 
    * _Provide domain-specific functionality:_

        Службы домена должны предоставлять специфическую для домена функциональность, которая может использоваться несколькими сущностями или объектами значений. Сюда могут входить операции, в которых участвуют несколько сущностей или объектов стоимости, или операции, которые естественным образом не входят в обязанности конкретной сущности или объекта стоимости.

    * _Encapsulate business logic:_

        Службы домена должны инкапсулировать бизнес-логику и обеспечивать выполнение правил и ограничений домена. Например, доменная служба может гарантировать выполнение определенных условий, прежде чем разрешить выполнение доменной операции, или накладывать ограничения на доменные объекты, чтобы гарантировать их согласованность и достоверность.

    * _Provide a consistent interface:_

        Службы домена должны предоставлять последовательный и четко определенный интерфейс для взаимодействия с прикладным уровнем. Этот интерфейс должен абстрагироваться от деталей того, как реализуется специфическая для домена функциональность, и обеспечивать простой и интуитивно понятный способ взаимодействия прикладного уровня с моделью домена.

    * _Be technology agnostic:_

        Сервисы домена должны быть технологически независимыми и не зависеть от каких-либо конкретных деталей реализации или фреймворков. Это гарантирует, что доменная модель отделена от конкретных технологий, используемых в приложении, что делает ее более гибкой и простой в сопровождении.

    * _Be easily testable:_

        Сервисы домена должны быть спроектированы таким образом, чтобы их можно было легко тестировать, что позволяет проводить всестороннее модульное тестирование модели домена. Это гарантирует, что модель домена корректна и последовательна, и что она ведет себя так, как ожидается в различных сценариях.

### Application layer:

Этот слой содержит бизнес-логику системы. Он получает запросы от презентационного уровня и координирует действия доменного и инфраструктурного уровней для создания ответа. Прикладной уровень должен быть спроектирован таким образом, чтобы его можно было повторно использовать для различных интерфейсов или платформ. Он также должен быть спроектирован таким образом, чтобы его можно было тестировать в отрыве от других уровней.

1. **Application services:**

    Сервис приложения - это объект без статического состояния, который выполняет определенную задачу или операцию в рамках прикладного уровня. Прикладные сервисы обычно используются для координации действий между различными доменными объектами или агрегатами или для выполнения сложной бизнес-логики, в которой участвуют несколько доменных объектов или агрегатов. Прикладной уровень определяет прикладные сервисы и их операции.

    Вот некоторые функции, которые прикладные сервисы должны выполнять на прикладном уровне:

    * _Implement use cases:_

        Прикладные сервисы должны реализовывать сценарии использования приложения, которые представляют собой конкретные задачи или функции, которые приложение предоставляет пользователям. Например, приложение электронной коммерции может иметь сценарии использования для добавления товаров в корзину, оформления заказа или просмотра истории заказов.

    * _Orchestrate domain objects:_

        Службы приложения должны организовывать взаимодействие между уровнем представления и уровнем домена, используя объекты домена, такие как сущности, объекты значений и агрегаты. Это включает в себя координацию получения и хранения данных из хранилищ, а также управление созданием и манипулированием доменными объектами.

    * _Handle transactions:_

        Службы приложений должны обрабатывать транзакции, обеспечивая атомарное и последовательное выполнение операций домена. Это включает в себя обеспечение фиксации всех изменений в объектах домена в базе данных в рамках одной транзакции, а также обработку и откат любых ошибок и исключений, если это необходимо.

    * _Expose APIs:_

        Прикладные сервисы должны предоставлять API, которые могут быть вызваны уровнем представления, позволяя пользователям взаимодействовать с приложением. Эти API должны быть четко определены и предоставлять пользователям ясный и последовательный интерфейс для взаимодействия.

    * _Be technology-specific:_

        В отличие от доменных служб, которые должны быть независимы от технологии, прикладные службы могут быть технологически специфичными и использовать конкретные детали реализации и фреймворки. Это позволяет прикладным сервисам использовать специфические особенности и возможности технологий, используемых в приложении, что делает их более эффективными и действенными.

    * _Be easily testable:_

        Прикладные сервисы должны быть легко тестируемыми, что позволяет проводить комплексное модульное тестирование логики приложения. Это гарантирует, что приложение ведет себя правильно и последовательно, и что оно предоставляет пользователям ожидаемую функциональность.

2. **Use cases:**

    Вариант использования - это конкретный сценарий или последовательность действий, которые пользователь может выполнить в системе. Варианты использования обычно представлены в виде серии шагов или взаимодействий между пользователем и системой и включают создание, изменение или получение данных в системе. Прикладной уровень определяет сценарии использования и соответствующие шаги или взаимодействия.

    Вот некоторые функции, которые должны выполнять варианты использования на уровне приложения:

    * _Define the user goals:_

        Варианты использования должны определять цели и задачи пользователей, а также то, как они могут быть достигнуты с помощью приложения. Например, сценарий использования для приложения электронной коммерции может звучать так: "Оформить заказ на товар".

    * _Describe the user interactions:_

        Примеры использования должны описывать конкретные действия пользователя, необходимые для достижения его целей. Это включает в себя входные данные, требуемые от пользователя, и ожидаемые выходы или результаты сценария использования.

    * _Be independent and self-contained:_

        Примеры использования должны быть независимыми и самодостаточными, представляя собой конкретную задачу или функцию приложения. Это гарантирует, что варианты использования могут разрабатываться, тестироваться и поддерживаться независимо друг от друга, что делает приложение более модульным и облегчает его поддержку.

    * _Be implementable by an application service:_

        Варианты использования должны быть реализуемы прикладным сервисом, который организует взаимодействие между уровнем представления и уровнем домена для реализации варианта использования. Сервис приложения должен реализовать необходимую бизнес-логику для достижения целей пользователя, используя объекты домена, такие как сущности, объекты значений и агрегаты.

    * _Be testable:_

        Примеры использования должны быть разработаны таким образом, чтобы их можно было легко тестировать, что позволяет проводить комплексное модульное тестирование логики приложения. Это гарантирует, что примеры использования ведут себя правильно и последовательно, и что они предоставляют пользователям ожидаемую функциональность.

    * _Be documented:_

        Примеры использования должны быть хорошо документированы, предоставляя четкие и ясные описания пользовательских целей, взаимодействия и ожидаемых результатов. Это гарантирует, что примеры использования могут быть легко поняты разработчиками и заинтересованными сторонами, и что они обеспечивают четкий и последовательный интерфейс для взаимодействия с пользователями.

3. **Application interfaces:**

    Интерфейс приложения - это интерфейс, который определяет, как система может быть доступна и использована внешними системами или компонентами. Он может включать API, веб-сервисы, интерфейсы командной строки или графические пользовательские интерфейсы. Прикладной уровень определяет прикладные интерфейсы и их операции.

    * _Define the input and output data types:_

        Интерфейсы приложений должны определять типы данных, которые используются в качестве входных и выходных данных прикладных служб. Это включает в себя определение формата и структуры входных данных, а также формата и структуры выходных данных.

    * _Provide a clear and consistent interface:_

        Интерфейсы приложений должны обеспечивать четкий и согласованный интерфейс для взаимодействия уровня представления с прикладным уровнем. Это включает в себя определение имен и сигнатур методов и функций, которые могут быть вызваны, а также ожидаемых входных и выходных данных.

    * _Ensure separation of concerns:_

        Интерфейсы приложений должны гарантировать, что уровень представления отделен от базовой бизнес-логики приложения. Это означает, что уровень представления не должен иметь прямого доступа к объектам домена, таким как сущности или объекты значений, но вместо этого должен взаимодействовать со службами приложений через интерфейсы приложений.

    * _Enable multiple Presentation layer implementations:_

        Интерфейсы приложений должны позволять нескольким реализациям уровня представления взаимодействовать с прикладным уровнем. Это означает, что службы приложений должны иметь возможность взаимодействовать с различными типами пользовательских интерфейсов, такими как веб-интерфейс или мобильный интерфейс, не требуя каких-либо изменений в базовой бизнес-логике.

    * _Be testable:_

        Интерфейсы приложений должны быть спроектированы таким образом, чтобы их можно было легко тестировать, обеспечивая всестороннее модульное тестирование логики приложения. Это гарантирует, что интерфейсы приложений ведут себя правильно и согласованно и что они обеспечивают ожидаемую функциональность уровня представления.

    * _Be documented:_

        Интерфейсы приложений должны быть хорошо задокументированы, предоставляя четкие и краткие описания методов и функций, которые могут быть вызваны, а также ожидаемые входные и выходные данные. Это гарантирует, что интерфейсы могут быть легко поняты разработчиками и заинтересованными сторонами, и что они обеспечивают четкий и согласованный интерфейс для взаимодействия с уровнем представления.

4. **Application events:**

    Событие приложения - это уведомление или сигнал, который генерируется системой в ответ на определенное действие или событие. События приложения могут использоваться для запуска других действий или операций в системе или для уведомления внешних систем или компонентов об изменениях или обновлениях в системе. Прикладной уровень определяет прикладные события и их триггеры.

    Вот некоторые функции, которые события приложения должны выполнять на прикладном уровне:

    * _Provide a decoupled way to communicate with external systems:_

        События приложения обеспечивают способ взаимодействия с внешними системами. Это означает, что внешней системе не нужно знать о деталях служб приложений, а службам приложений не нужно знать о деталях внешней системы. Вместо этого события действуют как общий интерфейс между двумя системами.

    * _Ensure loose coupling between systems:_

        События приложения обеспечивают слабую связь между службами приложений и внешними системами, с которыми они взаимодействуют. Это означает, что изменения в одной системе не влияют на другую систему, и каждая система может развиваться независимо, не влияя на другую.

    * _Enable extensibility:_

        События приложения обеспечивают расширяемость приложения, поскольку новые события могут быть добавлены в систему, не влияя на существующие события или базовую бизнес-логику. Это означает, что приложение может быть легко расширено для поддержки новых функций, не требуя внесения изменений в существующий код.

    * _Provide a way to handle errors:_

        События приложения предоставляют способ обработки ошибок, возникающих внутри приложения. Это означает, что ошибки могут регистрироваться, сообщаться или обрабатываться способом, подходящим для конкретного приложения.

    * _Enable testing:_

        События приложения позволяют проводить тестирование служб приложений изолированно, позволяя генерировать фиктивные события и передавать их службам. Это означает, что сервисы можно тестировать, не требуя, чтобы внешние системы были доступны или полностью функционировали.

    * _Be documented:_

        События приложения должны быть хорошо задокументированы, предоставляя четкие и краткие описания событий и связанных с ними данных. Это гарантирует, что события могут быть легко поняты разработчиками и заинтересованными сторонами и что они обеспечивают четкий и согласованный интерфейс между службами приложений и внешними системами.

### Presentation layer:

Этот слой отвечает за обработку пользовательского интерфейса и пользовательского ввода. Он получает ввод от пользователя и преобразует его в запрос, который может быть понят прикладным уровнем. Он также форматирует выходные данные, генерируемые прикладным уровнем, в формат, который может быть показан пользователю. Презентационный уровень должен быть спроектирован так, чтобы его было легко модифицировать, чтобы изменения в пользовательском интерфейсе могли быть сделаны без влияния на прикладной уровень или уровень домена.

1. **UI controllers:**

    UI-контроллер - это объект или функция, которая управляет компонентами пользовательского интерфейса, такими как кнопки, формы и представления. UI-контроллер получает пользовательский ввод, координирует действия с прикладным уровнем и обновляет пользовательский интерфейс, чтобы отразить текущее состояние системы. В Rust контроллеры пользовательского интерфейса могут быть реализованы с помощью функций Rust или веб-фреймворков, таких как Actix-web или Rocket.

    Вот некоторые функции, которые контроллеры пользовательского интерфейса должны выполнять на уровне представления:

    * _Handle user input:_

        Контроллеры пользовательского интерфейса должны отвечать за обработку пользовательского ввода. Это означает, что они должны иметь возможность получать входные данные от пользователя и переводить их в формат, который может быть понятен службам приложений.

    * _Interact with the application services:_

        Контроллеры пользовательского интерфейса должны отвечать за взаимодействие со службами приложений на прикладном уровне. Это означает, что они должны иметь возможность вызывать соответствующие службы приложений и передавать введенные пользователем данные в качестве параметров.

    * _Render output:_

        Контроллеры пользовательского интерфейса должны отвечать за рендеринг выходных данных служб приложений и отображение их пользователю. Это означает, что они должны иметь возможность преобразовывать выходные данные в формат, который может быть отображен пользовательским интерфейсом, таким как HTML, CSS или JavaScript.

    * _Provide feedback to the user:_

        Контроллеры пользовательского интерфейса должны предоставлять обратную связь пользователю, чтобы указать статус приложения, например, когда операция завершена или произошла ошибка. Это означает, что они должны иметь возможность отображать сообщения, уведомления или оповещения для пользователя способом, подходящим для конкретного приложения.

    * _Handle user navigation:_

        Контроллеры пользовательского интерфейса должны отвечать за управление пользовательской навигацией, такой как перемещение между различными экранами или страницами внутри приложения. Это означает, что они должны иметь возможность реагировать на действия пользователя, такие как щелчки по кнопкам или ссылкам, и направлять пользователя на соответствующий экран или страницу.

    * _Be platform-independent:_

        Контроллеры пользовательского интерфейса должны быть независимыми от платформы, что означает, что они должны иметь возможность работать на разных платформах или устройствах, таких как настольные, мобильные или веб-браузеры. Это означает, что они должны быть разработаны таким образом, чтобы быть совместимыми с конкретной платформой или устройством, на котором они работают, и что они должны использовать стандартные или зависящие от платформы технологии, такие как HTML, CSS или JavaScript.

2. **Presenters:**

    Ведущие: Презентер - это объект или функция, которая подготавливает данные из прикладного уровня для представления пользователю. Презентер форматирует данные в подходящий формат, например, HTML или JSON, и передает их контроллеру пользовательского интерфейса для отображения. В Rust презентеры могут быть реализованы с помощью функций Rust или веб-фреймворков, таких как Handlebars или Serde.

    * _Receive data from application services:_

        Уровень презентатора получает данные от служб приложений на прикладном уровне. Эти данные обычно представлены в виде простых структур данных или объектов.

    * _Format the data:_

        Уровень презентатора отвечает за форматирование данных, полученных с прикладного уровня, в формат, подходящий для пользовательского интерфейса. Это может включать преобразование данных в определенный формат, такой как HTML, JSON или XML.

    * _Adapt the data to the UI:_

        Уровень презентатора отвечает за адаптацию форматированных данных к конкретной используемой структуре пользовательского интерфейса или технологии. Это может включать сопоставление данных с определенными компонентами пользовательского интерфейса, такими как таблицы, формы или диаграммы.

    * _Handle errors and exceptions:_

        Уровень презентатора отвечает за обработку ошибок и исключений, которые могут возникнуть во время форматирования или адаптации данных. Это может включать отображение сообщений об ошибках или уведомлений пользователю или протоколирование ошибок для дальнейшего анализа.

    * _Provide hooks for UI controllers:_

        Уровень Presenter должен предоставлять хуки или интерфейсы, которые позволяют контроллерам пользовательского интерфейса получать доступ к отформатированным и адаптированным данным. Это может включать определение функций или методов, которые контроллеры пользовательского интерфейса могут вызывать для извлечения данных, или определение прослушивателей событий, которые запускаются при обновлении данных.

    * _Be platform-independent:_

        Подобно контроллерам пользовательского интерфейса, презентеры должны быть независимыми от платформы, что означает, что они должны иметь возможность работать на разных платформах или устройствах, таких как настольные, мобильные или веб-браузеры. Это означает, что они должны быть разработаны таким образом, чтобы быть совместимыми с конкретной платформой или устройством, на котором они работают, и что они должны использовать стандартные или зависящие от платформы технологии, такие как HTML, CSS или JavaScript.

3. **Views:**

    Представление - это компонент пользовательского интерфейса, который отображает информацию для пользователя и позволяет ему взаимодействовать с системой. Представления обычно реализуются в виде HTML-шаблонов, но могут быть реализованы и с помощью других технологий, таких как собственные наборы инструментов GUI или веб-фреймворки. В Rust представления могут быть реализованы с помощью HTML-шаблонов и веб-фреймворков, таких как Handlebars или Tera.

    * _Receive data from the Presenter layer:_

        Уровень представления получает данные от уровня презентатора, который отвечает за форматирование и адаптацию данных, полученных от уровня приложения, в формат, подходящий для пользовательского интерфейса. Эти данные обычно представлены в виде структурированных данных, таких как JSON или XML.

    * _Render the UI:_

        Уровень представления отвечает за рендеринг пользовательского интерфейса на основе данных, полученных от уровня презентатора. Это может включать создание HTML-элементов, их стилизацию с помощью CSS и добавление интерактивности с помощью JavaScript.

    * _Handle user input:_

        Уровень представления отвечает за обработку пользовательского ввода, и передачу входных данных соответствующему контроллеру пользовательского интерфейса на уровне презентатора.

    * _Update the UI:_

        Уровень представления отвечает за обновление пользовательского интерфейса в ответ на изменения в данных или вводимых пользователем данных. Это может включать повторный рендеринг частей пользовательского интерфейса или обновление определенных элементов в ответ на изменения данных.

    * _Provide hooks for UI controllers:_

        Уровень представления должен предоставлять хуки или интерфейсы, которые позволяют контроллерам пользовательского интерфейса получать доступ к отображаемому пользовательскому интерфейсу и обрабатывать пользовательский ввод. Это может включать определение функций или методов, которые контроллеры пользовательского интерфейса могут вызывать для доступа к определенным элементам пользовательского интерфейса или регистрации прослушивателей событий.

    * _Be platform-independent:_

        Подобно контроллерам пользовательского интерфейса и средствам представления, представления должны быть независимыми от платформы, что означает, что они должны иметь возможность запускаться на разных платформах или устройствах, таких как настольные, мобильные или веб-браузеры. Это означает, что они должны быть разработаны таким образом, чтобы быть совместимыми с конкретной платформой или устройством, на котором они работают, и что они должны использовать стандартные или зависящие от платформы технологии, такие как HTML, CSS или JavaScript.

4. **API endpoints:**

    Конечная точка API - это интерфейс, который позволяет внешним системам или компонентам получать доступ и использовать систему. Конечные точки API обычно используют протокол веб-интерфейса API, такой как REST или GraphQL, и могут использоваться для различных целей, таких как обмен данными или интеграция с другими системами. В Rust конечные точки API могут быть реализованы с помощью веб-фреймворков, таких как Actix-web или Rocket.
    
    * _Receive HTTP requests:_

        Конечные точки API должны получать HTTP-запросы от клиентов, которые могут содержать такие данные, как параметры запроса, заголовки запроса или тела запроса. Конечная точка должна проанализировать запрос и извлечь все соответствующие данные.

    * _Authenticate and authorize the request:_

        В зависимости от требований приложения конечным точкам API может потребоваться аутентифицировать и авторизовать запрос перед его обработкой. Это может включать проверку учетных данных или разрешений клиента в базе данных или внешней службе.

    * _Handle the request:_

        Как только запрос аутентифицирован и авторизован, конечная точка API должна обработать запрос, вызвав соответствующий вариант использования на прикладном уровне. Это может включать передачу данных, извлеченных из запроса, в вариант использования и получение ответа.

    * _Format the response:_

        После получения ответа от варианта использования конечная точка API должна отформатировать данные в подходящий для клиента формат, такой как JSON или XML. Конечная точка также должна установить любые соответствующие заголовки HTTP-ответа, такие как тип содержимого или коды состояния.

    * _Return the response:_

        Наконец, конечная точка API должна вернуть клиенту отформатированный ответ в форме HTTP-ответа. Этот ответ должен содержать отформатированные данные и любые соответствующие заголовки HTTP-ответа.

    * _Be platform-independent_

        Подобно Views и другим средствам представления, конечные точки API должны быть независимыми от платформы, что означает, что они должны иметь возможность работать на разных платформах или устройствах, таких как настольные, мобильные или веб-браузеры. Это означает, что они должны быть спроектированы таким образом, чтобы быть совместимыми с конкретной платформой или устройством, на которых они работают, и что они должны использовать стандартные или зависящие от платформы технологии, такие как HTTP или JSON.

### Infrastructure layer:

Этот уровень обеспечивает техническую инфраструктуру, необходимую для поддержки системы. Он включает такие компоненты, как базы данных, файловые системы, сетевые протоколы и внешние API. Инфраструктурный уровень должен быть модульным, чтобы можно было менять местами или заменять различные компоненты без ущерба для других уровней. Он также должен быть пригоден для тестирования, чтобы его можно было тестировать в отрыве от других уровней.

1. **Data access objects (DAO):**

    * Объект доступа к данным - это объект или функция, предоставляющая интерфейс для доступа к данным из базы данных или другого механизма хранения. DAO инкапсулируют низкоуровневые детали доступа к данным и обеспечивают простой и последовательный интерфейс для взаимодействия прикладного уровня с базой данных. В Rust DAO могут быть реализованы с помощью таких библиотек Rust, как Diesel или SQLx.

    На уровне инфраструктуры объекты доступа к данным (DAO) отвечают за обеспечение интерфейса между уровнем домена и уровнем сохраняемости. Шаблон DAO отделяет логику доступа к данным от бизнес-логики, и такое разделение задач облегчает обслуживание, тестирование и масштабируемость приложения.

    DAOS должны предоставлять операции CRUD (создание, чтение, обновление, удаление) для объектов домена способом, независимым от базовой базы данных или технологии сохранения. DAO должен инкапсулировать логику взаимодействия с базой данных или другим механизмом хранения, чтобы объекты домена не были связаны со спецификой технологии хранения.

    В Rust DAOS могут быть реализованы с использованием различных подходов, включая использование библиотеки ORM (Object Relational Mapping), такой как Diesel, или написание необработанных SQL-запросов непосредственно с использованием драйвера базы данных. Независимо от подхода, DAO должен предоставлять интерфейс, который абстрагируется от деталей базовой технологии хранения.

    DAO должен отвечать за сопоставление данных между объектами домена и схемой базы данных, чтобы изменения ни в домене, ни на уровне хранения не влияли на другой уровень. Он также должен обеспечивать механизмы для обработки транзакций, пакетных запросов и обработки ошибок, которые могут возникать во время операций доступа к данным.

    В дополнение к операциям CRUD DAOS могут также предоставлять другие операции, специфичные для модели предметной области или варианта использования, такие как поиск или запрос определенных наборов данных. Важно сохранить интерфейс DAO максимально простым и сфокусированным, чтобы свести к минимуму связь между уровнем домена и уровнем инфраструктуры.

2. **Repositories:**

    * Репозиторий - это объект или функция, которая управляет коллекцией доменных объектов или агрегатов и предоставляет интерфейс для запросов и модификации. Репозитории абстрагируют детали хранения и извлечения данных и предоставляют высокоуровневый интерфейс для взаимодействия прикладного уровня с доменным уровнем. В Rust репозитории могут быть реализованы с помощью библиотек Rust, таких как Diesel или SQLx.

    На уровне инфраструктуры репозитории отвечают за реализацию логики доступа к данным, необходимой для хранения и извлечения объектов домена из механизма постоянного хранения, такого как реляционная база данных или хранилище документов. Хранилища обеспечивают уровень абстракции между доменным уровнем и уровнем доступа к данным, позволяя доменному уровню оставаться независимым от конкретных деталей технологии хранения.

    Репозитории должны обеспечивать операции CRUD (создание, чтение, обновление, удаление) для объектов домена способом, независимым от базовой базы данных или технологии сохранения. Репозиторий должен инкапсулировать логику взаимодействия с базой данных или другим механизмом хранения, чтобы объекты домена не были связаны со спецификой технологии хранения.

    В Rust репозитории могут быть реализованы с использованием различных подходов, включая использование библиотеки ORM (Object Relational Mapping), такой как Diesel, или написание необработанных SQL-запросов непосредственно с использованием драйвера базы данных. Независимо от подхода, репозиторий должен предоставлять интерфейс, который абстрагирует детали базовой технологии хранения.

    Репозиторий должен отвечать за сопоставление данных между объектами домена и схемой базы данных, чтобы изменения либо в домене, либо на уровне хранилища не влияли на другой уровень. Он также должен обеспечивать механизмы для обработки транзакций, пакетных запросов и обработки ошибок, которые могут возникать во время операций доступа к данным.

    В дополнение к операциям CRUD репозитории могут также предоставлять другие операции, специфичные для модели предметной области или варианта использования, такие как поиск или запрос определенных наборов данных. Важно сохранить интерфейс репозитория максимально простым и сфокусированным, чтобы свести к минимуму связь между уровнем домена и уровнем инфраструктуры.

    В целом, хранилища являются важной частью уровня инфраструктуры, обеспечивая мост между моделью домена и уровнем сохраняемости, который позволяет приложению хранить и извлекать объекты домена эффективным, ремонтопригодным и масштабируемым способом.

3. **External services:**

    * Внешние сервисы - это сторонние сервисы или API, от которых зависит работа приложения. Примерами внешних сервисов являются платежные шлюзы, службы обмена сообщениями или платформы социальных сетей. В Rust доступ к внешним сервисам можно получить с помощью таких библиотек Rust, как Reqwest или Hyper.

    На уровне инфраструктуры внешние службы отвечают за интеграцию с внешними системами или службами, такими как сторонние API, очереди обмена сообщениями, службы электронной почты или другие внешние источники данных. Эти службы предоставляют уровень абстракции, который инкапсулирует детали взаимодействия с этими внешними системами, позволяя остальной части приложения оставаться отделенной от специфики этих систем.

    Внешние службы должны обеспечивать четкий и согласованный интерфейс для взаимодействия с внешней системой, с методами, которые абстрагируются от деталей базовой реализации. Например, если внешняя служба является REST API, служба должна предоставлять методы для выполнения HTTP-запросов и обработки ответа, но детали конкретной используемой HTTP-библиотеки или фреймворка должны быть скрыты от остальной части приложения.

    В Rust внешние службы могут быть реализованы с использованием различных подходов, включая использование клиентских библиотек HTTP, библиотек очереди сообщений или клиентских библиотек электронной почты. Независимо от подхода, внешняя служба должна предоставлять интерфейс, который абстрагируется от деталей базовой реализации.

    Внешние службы также должны предоставлять механизмы для обработки ошибок или исключений, которые могут возникать во время связи с внешней системой, таких как сетевые ошибки или ограничения скорости API. Это может включать повторную попытку неудачных запросов, корректную обработку ошибок или предоставление приложению уведомлений о любых возникающих проблемах.

    В целом, внешние службы являются важной частью уровня инфраструктуры, обеспечивая связующее звено между приложением и внешними системами, которое позволяет приложению интегрироваться с другими системами или службами эффективным, ремонтопригодным и масштабируемым способом. Инкапсулируя детали взаимодействия с внешними системами, внешние службы помогают отделить остальную часть приложения от этих особенностей, облегчая его обслуживание и модификацию с течением времени.

4. **File system access:**

    * Файловая система - это общий ресурс, используемый многими приложениями для хранения и получения файлов и других данных. В Rust доступ к файловой системе может быть реализован с помощью встроенных в Rust библиотек файлового ввода-вывода или библиотек сторонних производителей, таких как fs2.

    На уровне инфраструктуры доступ к файловой системе относится к способности приложения читать и записывать файлы в локальной файловой системе или в сетевой файловой системе. Это может включать взаимодействие с файлами на диске, чтение или запись файлов конфигурации или доступ к файлам, хранящимся в службе облачного хранения.

    Доступ к файловой системе в Rust может быть реализован с помощью модуля std::fs стандартной библиотеки, который предоставляет функции для создания, чтения и записи файлов, а также манипулирования каталогами и метаданными файлов.

    Функции, предоставляемые компонентом доступа к файловой системе, должны обеспечивать четкий и согласованный интерфейс для доступа к файлам и каталогам с методами, которые абстрагируются от деталей базовой реализации. Это может включать сокрытие деталей используемой файловой системы или системы хранения данных и предоставление методов обработки ошибок или исключений, которые могут возникать во время операций с файловой системой.

    Компоненты доступа к файловой системе также должны учитывать последствия для безопасности, такие как обеспечение доступа к файлам только для авторизованных пользователей и надежное и безопасное решение таких проблем, как разрешения файлов, блокировка файлов или конфликты файлов.

    В дополнение к базовым операциям с файловой системой компоненты доступа к файловой системе могут также предоставлять такие функциональные возможности, как механизмы резервного копирования и восстановления, сжатие и шифрование файлов или интеграция с другими файловыми системами или инструментами.

    В целом, доступ к файловой системе является важным компонентом уровня инфраструктуры, обеспечивающим приложению эффективный, безопасный и масштабируемый способ взаимодействия с локальными или удаленными файловыми системами. Инкапсулируя детали операций файловой системы, компонент доступа к файловой системе помогает отделить остальную часть приложения от этих особенностей, облегчая его обслуживание и модификацию с течением времени.
